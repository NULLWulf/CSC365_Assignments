<!DOCTYPE html>
<html lang="en">
  <head>
    <link rel="stylesheet" href="../css/homepage.css" />
    <script src="../js/homepage.js" defer></script>
      <script src="https://d3js.org/d3.v6.min.js"></script>
    <meta charset="UTF-8" />
    <title>Yelp Similarity Tester</title>
  </head>
  <body>
    <div style="width: 50%; font-size: 14px">
      <h1>Yelp Dataset Recommendation Engine</h1>
      <p style="font-size: 14px">
        Select an item from the dropdown to get a randomly related business. Upon selection details of the selected business will appears
        along with its related business within a cluster and the cluster's medoid.  Businesses are clustered based on their location and
        star rating.  The related business is the business within the cluster that is closest to the selected business.  The medoid is the
        business within the cluster that is closest to all other businesses in the cluster.  This statistical method is known as k-medoids.
      </p>
      <select id="businesses"></select>
      <div class="details-box" style="display: none">
        <h2>Cluster Details</h2>
      <p id="cluster-size"></p>
        <h3>Selected Business</h3>
        <p id="selected-name"></p>
        <p id="selected-city"></p>
        <p id="selected-state"></p>
        <p id="selected-lat"></p>
        <p id="selected-long"></p>
        <p id="selected-stars"></p>
        <h3>Related Business</h3>
        <p id="related-name"></p>
        <p id="related-city"></p>
        <p id="related-state"></p>
        <p id="related-lat"></p>
        <p id="related-long"></p>
        <p id="related-stars"></p>
        <h3>Medoid Business</h3>
        <p id="medoid-name"></p>
        <p id="medoid-city"></p>
        <p id="medoid-state"></p>
        <p id="medoid-lat"></p>
        <p id="medoid-long"></p>
        <p id="medoid-stars"></p>
      </div>
      <h2>Calculation Process</h2>
      <h3>Application</h3>
      <ul>
        <li>1) Loads Yelp Dataset of Businesses, iterates through line by line getting Restaurant businesses with a minimum of 100
          reviews, meanwhile it saves each business as a file and adds the filename to a Extensible Hash Table (EHT) which in this case 
          is used as a file index.  The EHT is then serialized and saved to disk.</li>
        </li>
        <li>2) The K-Medoids Statistical component is executed, the EHT is loaded and deserialized.  Then the EHT is iterated through the
          business files are loaded and converted to a vector of the business's location and star rating.  The K-Medoids algorithm is started
          iterating through the dataset to create k-number of clusters (in this case just 10)
        </li>
        <li>
          3) As a result of the algorithm, a 2D array like data structure is returned with some bookkeeping information each
          dimension.  The first dimension is the cluster number and also contains the file name for the medoid of cluster
          and the second dimension is the business file name along with metric information such as latitude, longitude, and
          and stars.  This data structured is then serialized and saved to disk.
        </li>
      </ul>
      <h3>Loader</h3>
      <ul>
        <li>1) Loads the serialized K-Medoids data structure from disk and deserializes it.</li>
        <li>2) Server is started on port 7500 to serve random business list and respond with related clusters</li>
        <li>3) Upon selection of a business, business id is sent to back end, filename is retrieved from EHT, and file is loaded
          as business object.
        </li>
        <li>4) Using the lat, long and stars of the business a Calculation is performed on each saved cluster medoid to determine which cluster the
          selected business belongs to.  The cluster is then loaded and the selected business is compared to each business in the cluster
          to determine which business is the closest to the selected business.  The closest business is then returned to the front end, along with selected
          and medoid business for the given cluster. 
        </li>

      </ul>
    </div>
    <div id="graph"></div>
    <div id="tooltip" style="position: absolute; visibility: hidden;"></div>


    <script>
      let select = document.getElementById("businesses");
      let detailsBox = document.querySelector(".details-box");
      // function to get random business list and populate select element
      async function getBusinessList() {
        fetch("/random")
          .then((response) => response.json())
          .then((data) => {
            console.log(data);
            // filter out empty values
            let businesses = data.filter(
              (business) => business.name.trim() !== ""
            );
            // populate select element
            console.log(businesses);
            businesses.forEach((business) => {
              let option = document.createElement("option");

              option.value = business.name;
              option.text = business.name;
              let input = document.createElement("input");
              input.type = "hidden";
              input.name = "file_id";
              input.value = business.file_id;
              console.log(input);
              option.appendChild(input);

              select.add(option);
            });
          })
          .catch((error) => console.error(error));
      }

      select.addEventListener("change", () => {
        let selectedOption = select.options[select.selectedIndex];
        let businessId = selectedOption.querySelector(
          '[name="file_id"]'
        ).value;
        fetch(`/clustered?file_id=${businessId}`)
          .then((response) => response.json())
          .then((data) => {
            console.log(data);

            // update the details box with the relevant information
        // call an async function now
          async function updateDetailsBox() {
            drawGraph(businessId);
          }
        let selectedBiz = data.business_selected;
        let medoidBiz = data.business_medoid;
        let relatedBiz = data.businesses_similar;
        let clusterSize = data.cluster_size;

        document.getElementById("selected-name").textContent = `Selected Business: ${selectedBiz.name}`;
        document.getElementById("selected-city").textContent = `City: ${selectedBiz.city}`;
        document.getElementById("selected-state").textContent = `State: ${selectedBiz.state}`;
        document.getElementById("selected-lat").textContent = `Latitude: ${selectedBiz.latitude}`;
        document.getElementById("selected-long").textContent = `Longitude: ${selectedBiz.longitude}`;
        document.getElementById("selected-stars").textContent = `stars: ${selectedBiz.stars}`;

        document.getElementById("medoid-name").textContent = `Medoid Business: ${medoidBiz.name}`;
        document.getElementById("medoid-city").textContent = `City: ${medoidBiz.city}`;
        document.getElementById("medoid-state").textContent = `State: ${medoidBiz.state}`;
        document.getElementById("medoid-lat").textContent = `Latitude: ${medoidBiz.latitude}`;
        document.getElementById("medoid-long").textContent = `Longitude: ${medoidBiz.longitude}`;
        document.getElementById("medoid-stars").textContent = `stars: ${medoidBiz.stars}`;

        document.getElementById("related-name").textContent = `Related Business: ${relatedBiz.name}`;
        document.getElementById("related-city").textContent = `City: ${relatedBiz.city}`;
        document.getElementById("related-state").textContent = `State: ${relatedBiz.state}`;
        document.getElementById("related-lat").textContent = `Latitude: ${relatedBiz.latitude}`;
        document.getElementById("related-long").textContent = `Longitude: ${relatedBiz.longitude}`;
        document.getElementById("related-stars").textContent = `stars: ${relatedBiz.stars}`;
        document.getElementById("cluster-size").textContent = `Cluster Size: ${clusterSize}`;

        detailsBox.style.display = "block";
      })
      .catch((error) => console.error(error));
  });

function drawGraph(graphData) {
  // Set the dimensions of the canvas / graph
  const margin = { top: 20, right: 30, bottom: 30, left: 40 };
  const width = 960 - margin.left - margin.right;
  const height = 500 - margin.top - margin.bottom;

  // Set up the scales
  const xScale = d3.scaleBand()
    .range([0, width])
    .padding(0.1);
  const yScale = d3.scaleLinear()
    .range([height, 0]);
  const colorScale = d3.scaleOrdinal(d3.schemeCategory10);

  // Set up the SVG element and groups
  const svg = d3.select('#graph')
    .append('svg')
    .attr('width', width + margin.left + margin.right)
    .attr('height', height + margin.top + margin.bottom)
    .append('g')
    .attr('transform', `translate(${margin.left},${margin.top})`);
  const linksGroup = svg.append('g').attr('class', 'links');
  const nodesGroup = svg.append('g').attr('class', 'nodes');

  // Set up the tooltip
  const tooltip = d3.select('#tooltip');

  // Extract the nodes and edges from the graph data
  const nodes = graphData.nodes;
  const edges = graphData.edges;

  // Create a map of node IDs to nodes
  const nodeMap = new Map(nodes.map(node => [node.id, node]));

  // Find the connected path from the first node
  const connectedNodes = findConnectedNodes(edges, nodes[0]);

  // Set the domain of the x and y scales
  xScale.domain(connectedNodes.map(node => node.id));
  yScale.domain([0, d3.max(connectedNodes, node => node.value)]);

  // Create the links and nodes
  const links = linksGroup.selectAll('line')
    .data(edges.filter(edge => {
      return connectedNodes.includes(edge.source) && connectedNodes.includes(edge.target);
    }))
    .enter().append('line')
    .attr('stroke-width', d => d.weight)
    .attr('stroke', 'red');
     let nodeg = nodesGroup.selectAll('rect')
    .data(connectedNodes)
    .enter().append('rect')
    .attr('x', d => xScale(d.id))
    .attr('y', d => yScale(d.value))
    .attr('width', xScale.bandwidth())
    .attr('height', d => height - yScale(d.value))
    .attr('fill', d => colorScale(d.group))
    .on('mouseover', function(d) {
      tooltip.html(d.businessData)
        .style('left', `${d3.event.pageX}px`)
        .style('top', `${d3.event.pageY}px`)
        .style('visibility', 'visible');
    })
    .on('mouseout', function() {
      tooltip.style('visibility', 'hidden');
    });

  // Highlight the connected path in green
  nodes.filter(d => connectedNodes.indexOf(d) >= 0)
    .attr('fill', 'green');
  links.filter(edge => {
    return connectedNodes.indexOf(edge.source) >= 0 && connectedNodes.indexOf(edge.target) >= 0;
  })
    .attr('stroke', 'green');
}

  window.onload = getBusinessList;
</script>
